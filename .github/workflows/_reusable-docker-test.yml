name: Reusable - Docker Image Test

on:
  workflow_call:
    inputs:
      dockerfile:
        description: "Path to Dockerfile"
        required: true
        type: string
      context:
        description: "Build context"
        required: false
        default: "."
        type: string
      image-tag:
        description: "Local image tag for CI test"
        required: false
        default: "ci-docker-test"
        type: string
      test-port:
        description: "Port that the container exposes for HTTP test"
        required: false
        default: 0
        type: number
      healthcheck-path:
        description: "Path to call for healthcheck (e.g. /, /health)"
        required: false
        default: "/"
        type: string
      extra-env:
        description: |
          Optional environment variables to pass to docker run.
          Format: KEY=VALUE, one per line.
        required: false
        type: string

jobs:
  docker-test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build image for test
        env:
          DOCKERFILE_PATH: ${{ inputs.dockerfile }}
          BUILD_CONTEXT: ${{ inputs.context }}
          IMAGE_TAG: ${{ inputs.image-tag }}
        run: |
          echo "Building image $IMAGE_TAG from $DOCKERFILE_PATH with context $BUILD_CONTEXT"
          docker build -f "$DOCKERFILE_PATH" -t "$IMAGE_TAG" "$BUILD_CONTEXT"

      - name: Prepare docker env args
        id: prepare-env
        env:
          EXTRA_ENV: ${{ inputs.extra-env }}
        run: |
          ENV_ARGS=""

          if [ -n "${EXTRA_ENV}" ]; then
            echo "Preparing --env-file for docker run"

            ENV_FILE="docker.env"
            printf '%s\n' "${EXTRA_ENV}" > "${ENV_FILE}"

            echo "Env file created: ${ENV_FILE}"
            echo "Contents:"

            cat "${ENV_FILE}"

            ENV_ARGS="--env-file ${ENV_FILE}"
          fi

          echo "env_args=${ENV_ARGS}" >> "$GITHUB_OUTPUT"

      - name: Run container
        id: run-container
        if: ${{ inputs.test-port != 0 }}
        env:
          IMAGE_TAG: ${{ inputs.image-tag }}
          TEST_PORT: ${{ inputs.test-port }}
          HEALTHCHECK_PATH: ${{ inputs.healthcheck-path }}
        run: |
          echo "Starting container from image $IMAGE_TAG"

          ENV_ARGS="${{ steps.prepare-env.outputs.env_args }}"

          CONTAINER_ID=$(
            docker run -d \
              -p ${TEST_PORT}:${TEST_PORT} \
              ${ENV_ARGS} \
              "$IMAGE_TAG"
          )

          echo "Container: $CONTAINER_ID"
          echo "Waiting container to be ready..."

          sleep 10

          echo "container_id=${CONTAINER_ID}" >> "$GITHUB_OUTPUT"

      - name: Test HTTP healthcheck
        if: ${{ inputs.test-port != 0 }}
        env:
          HEALTHCHECK_PATH: ${{ inputs.healthcheck-path }}
          TEST_PORT: ${{ inputs.test-port }}
        run: |
          CONTAINER_ID="${{ steps.run-container.outputs.container_id }}"
          echo "Starting test with HTTP healthcheck of container: $CONTAINER_ID"

          echo "Calling healthcheck endpoint http://localhost:${TEST_PORT}${HEALTHCHECK_PATH}"
          if ! curl -f "http://localhost:${TEST_PORT}${HEALTHCHECK_PATH}"; then
            echo "Healthcheck failed. Container logs:"
            docker logs "$CONTAINER_ID" || true
            exit 1
          fi

          echo "Container test passed successfully!"

      - name: Remove docker container
        if: ${{ inputs.test-port != 0 }}
        run: |
          CONTAINER_ID="${{ steps.run-container.outputs.container_id }}"
          echo "Removing container: $CONTAINER_ID"

          docker rm -f "$CONTAINER_ID" || true
          echo "Removed container: $CONTAINER_ID"
